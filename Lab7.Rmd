---
title: "Lab7"
output: html_document
---

Joseph Crockett  
ES 207: Environmental Data Analysis  
April 1st, 2016  
Homework Assignment 7: Time & Space  


```{r global_options, include = FALSE}
knitr::opts_chunk$set(fig.width = 12, fig.height = 8, warning = FALSE, message = FALSE)

#check for needed packages, install if needed, then adds to environment
ndpkg <- function(p){
 if(!is.element(p,installed.packages()[,1]))
   {install.packages(p, dep = T)}
  require(p,character.only = T)
}
sapply(c("foreign", "ggplot2", "reshape", "raster", "rgdal","dplyr","gridExtra"), ndpkg)

#EDA function
CV1 <- function(x){
  print((sd(x)/mean(x))*100)
}

```


Objective Statement:   
Purposeful flooding of the Cosumnes River floodplain could stimulate localized recharge of the groundwater aquifer and spur fish populations.  However, the expense may not be worth the investment if flooding does not occure often enough. We will examine the discharge levels at the USGS gaging station at Michigan Bar to determine the percentage of years that discharges >= 800 cubic feet per second occur 100 days or more.  Groundwater aquifers will benefit if floods occur in 50% of years. 
Methods:  
Our first goal is to gather data from the California Data Exchange Center with a unique function that will extract from a query URL.  We will next remove leap days and examine monthly autocorrelation,  including total, mean, and maximum discharge by month.  The number of flood events (days during which average discharge equals or exceeds 800 cfs) per water year will finally be calculated

Data:  
We will retrive historical river conditions at Michigan Bar from the California Data Exchange Center for the period 1908 to 2015


Code: 
```{r Step 1}
# The provided function getCDEC encounters problems when the date format "m/d/Y" is used: csv files will not be written with the / symbol.  The fixed function, also provided, corrects this with the addition of "as.character(strptime(...))" on lines 53 and 54.  An alternative to this would be to use the function "format" to rearrange the start and end times to "m-d-Y" regardless of the input format.

#Extracting data from URL
get.dailyUSGS <- function(site, sensor, start, end){
  #site = site number (11335000 for Michigan Bar)
  #sensor = sensor parameter (00060 for discharge)
  #start and end values can be in mm-dd-yyyy or mm/dd/yyyy forms
  start <- format(as.Date(start, "%m/%d/%Y"),"%Y-%m-%d") #format date in form m - d - y for URL
  print(start)
  end <- format(as.Date(end,"%m/%d/%Y"), "%Y-%m-%d")
  print(end)
  print(site)
  print(sensor)
  print(paste0("http://waterdata.usgs.gov/nwis/dv?cb_",sensor,"=on&format=rdb&site_no=",site,"&referred_mo dule=sw&period=&begin_date=",start,"&end_date=",end))
  data <- read.table(paste0("http://waterdata.usgs.gov/nwis/dv?cb_",sensor,"=on&format=rdb&site_no=",site,"&referred_module=sw&period=&begin_date=",start,"&end_date=",end), header = T) #header = T removes one of the two unnecessary rows
  
  assign("daily_sf", data, envir = .GlobalEnv) #assign to the global environment
  
}

```

```{r Step 2}
get.dailyUSGS("11335000", "00060", "10/01/1907", "09/30/2015")

water_dat <- daily_sf
water_dat <- droplevels(water_dat[-1,]) #remove the first row
colnames(water_dat) [4:5] <- c("discharge_cfs","dat_qvalue") #rename the last two columns

water_dat[,"datetime"] <- as.POSIXct(water_dat[,"datetime"], tz = "America/Los_Angeles") #convert datetime into POSIXct format, with timezone PST.

water_dat[,"discharge_cfs"] <- as.double(as.character(water_dat[,"discharge_cfs"])) #convert discharge cfs to numeric(double format)

#From the Nevada division of water resources, 1 cfs for 24 hours = 1.9835 Acre-Feet
water_dat[,"discharge_afd"] <- 1.98347109902 * water_dat[,"discharge_cfs"]

```

```{r Step 3}
#Add year, month, and day columns, including water year and water month columns

#Extracting year, month, and day values from datetime column
water_dat[,"year"]<-as.numeric(format(water_dat[,"datetime"], format = "%Y"))  
water_dat[,"month"] <-as.numeric(format(water_dat[,"datetime"], format = "%m"))
water_dat[,"day"] <- as.numeric(format(water_dat[,"datetime"], format = "%d"))

#water years start October 1 and end september 30, thus for calender months >9, we can add 1 to the year because it will be in the next year. We also reorder months so that october = 1 and september =12
water_dat[,"water_year"] <- ifelse(water_dat[,"month"] > 9, water_dat[,"year"] + 1, water_dat[,"year"])
water_dat[,"water_month"] <- ifelse(water_dat[,"month"] > 9, water_dat[,"month"] - 9, water_dat[,"month"] + 3)

#removing leap days
water_dat <- water_dat[!(water_dat[,"month"] == 2 & water_dat[,"day"] == 29),]

#The function ts will create a time series object, ts, with attributes that make time series analysis easier, such as aligning time axes. Yearly totals will have seasonal variation, so the following functions aggregate by month/year


water_dat_mon_sum <- ts(as.vector(aggregate(discharge_afd ~ water_month + water_year, data = water_dat, FUN = sum)), frequency = 12)

water_dat_mon_mean <- ts(as.vector(aggregate(discharge_afd ~ water_month + water_year, data = water_dat, FUN = mean)), frequency = 12)

water_dat_mon_max <- ts(as.vector(aggregate(discharge_afd ~ water_month + water_year, data = water_dat, FUN = max)), frequency = 12)

#Determining driest year, wettest year, and year with highest daily average discharge
wat_yr_s <- aggregate(discharge_afd~water_year, data = water_dat, FUN = sum)

which.min(wat_yr_s$discharge_afd) #will show the row number of the minimum year sum of discharge_afd
#[1] 70
wat_yr_s[70,] #1977

which.max(wat_yr_s$discharge_afd) #similarly, the row number of the max value
#[1] 76
wat_yr_s[76,] #1983

#Interesting that the minimum and the maximum discharge years occur within 10 years of each other

#The year with the highest daily average discharge: Is this the year in which the highest flood occured?

which.max(water_dat$discharge_afd)
#[1] 32579

water_dat[32579,"datetime"]
#[1] "1997-01-02 PST"

#Plotting monthly hydrograph results for the above years: 1977, 1983, 1997

d1 <- as.data.frame(water_dat_mon_max)
d2 <- as.data.frame(water_dat_mon_sum)
d3 <- as.data.frame(water_dat_mon_mean)

#Max monthly discharge
df_max <- melt(list(max_77 = filter(d1, water_year == 1977), max_83 = filter(d1, water_year == 1983), max_97 = filter(d1, water_year == 1997)), id.vars = c("water_year", "water_month"))

ggplot(df_max, aes(x = as.factor(water_month), y = value, fill = as.factor(water_year))) + geom_bar(stat = "identity", position = "dodge") + theme_minimal() + labs(title = "Maximum monthly discharge, driest year, wettest year, and highest daily average", x = "Water Month", y = "Daily Discharge, AFD") + theme(legend.position = c(1,1), legend.justification = c(1,1)) + scale_fill_discrete(name = "Water Year")

#Mean monthly discharge
df_mean <- melt(list(mean_77 = filter(d2, water_year == 1977), mean_83 = filter(d2, water_year == 1983), mean_97 = filter(d2, water_year == 1997)), id.vars = c("water_year", "water_month"))

ggplot(df_mean, aes(x = as.factor(water_month), y = value, fill = as.factor(water_year))) + geom_bar(stat = "identity", position = "dodge") + theme_minimal() + labs(title = "Mean monthly discharge per month, driest year, wettest year, and highest daily average", x = "Water Month", y = "Daily Discharge, AFD") + theme(legend.position = c(1,1), legend.justification = c(1,1)) + scale_fill_discrete(name = "Water Year")

#total monthly discharge
df_sum <- melt(list(sum_77 = filter(d3, water_year == 1977), sum_83 = filter(d3, water_year == 1983), sum_97 = filter(d3, water_year == 1997)), id.vars = c("water_year", "water_month"))

ggplot(df_sum, aes(x = as.factor(water_month), y = value, fill = as.factor(water_year))) + geom_bar(stat = "identity", position = "dodge") + theme_minimal() + labs(title = "Total monthly discharge, driest year, wettest year, and highest daily average", x = "Water Month", y = "Daily Discharge, AFD") + theme(legend.position = c(1,1), legend.justification = c(1,1)) + scale_fill_discrete(name = "Water Year")

#Autocorrelation functions of sum, mean, and max
acf(water_dat_mon_sum[,"discharge_afd"])
acf(water_dat_mon_mean[,"discharge_afd"])
acf(water_dat_mon_max[,"discharge_afd"])
#The pattern in the ACF indicates seasonality, especially considering that water year is being used..  Lags at approximately 6 months are negative (summer dry season to winter wet) and 1 year are positive (summer to summer or winter to winter).  Interestingly, the lags two years out are similar to one year away.

acf(water_dat_mon_sum[,"discharge_afd"]))
acf(water_dat_mon_mean[,"discharge_afd"])
acf(water_dat_mon_max[,"discharge_afd"])
```

```{r Step 4}
#Calculating flood events
#Flood days are defined as days in which discharges in excess of 800 cfs occur.


water_dat[,"flood"] <- ifelse(water_dat[,"discharge_cfs"] >= 800, 1, 0)

ggplot(water_dat, aes(x = datetime, y = discharge_cfs)) + geom_line() + geom_hline(yintercept = 800, col = "red", alpha = 1/2) + theme_minimal()

water_dat_flood <- aggregate(flood ~ water_year, data = water_dat, FUN = sum)

water_dat_flood$ab <- ifelse(water_dat_flood$flood >= 100, "Flood Year" , "Not Flood Year")

sum(ifelse(water_dat_flood$ab == "Flood Year", 1, 0)/nrow(water_dat_flood))
#[1] 0.3055556

ggplot(water_dat_flood, aes(x = water_year, y = flood, fill = ab)) + geom_bar(stat = "identity") + geom_hline(yintercept = 100, color = "orange", alpha = 1/2) + theme_minimal() + theme(legend.title = element_blank(), legend.position = "bottom")

```

Results:  
Discussion:  
Limitation:  
